// Generated by CoffeeScript 1.6.3
(function() {
  var appendMicros, clone, fromMicros, isArray, json, makeIter, toMicros;

  json = {};

  json.name = 'json1';

  json.url = 'http://sharejs.org/types/JSONv1';

  json.create = function(init) {
    if (init != null) {
      return init;
    } else {
      return null;
    }
  };

  json.checkValidOp = function(op) {};

  isArray = function(o) {
    return Object.prototype.toString.call(o) === '[object Array]';
  };

  json.checkList = function(elem) {
    if (!isArray(elem)) {
      throw new Error('Referenced element not a list');
    }
  };

  json.checkObj = function(elem) {
    if (elem.constructor !== Object) {
      throw new Error("Referenced element not an object (it was " + (JSON.stringify(elem)) + ")");
    }
  };

  /*
  eachMicro = (op, fn) ->
    for c in op
      if c.in
        for p in c.in
          fn 'in'
          fn {skip:p}
      else if c.out?
        for [0...c.out]
          fn 'out'
      else
        fn c
  */


  toMicros = json._toMicros = function(op) {
    var c, newOp, p, _i, _j, _k, _len, _len1, _ref, _ref1;
    newOp = [];
    for (_i = 0, _len = op.length; _i < _len; _i++) {
      c = op[_i];
      if (c["in"]) {
        _ref = c["in"];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          p = _ref[_j];
          newOp.push('in');
          newOp.push({
            skip: p
          });
        }
      } else if (c.out != null) {
        for (_k = 0, _ref1 = c.out; 0 <= _ref1 ? _k < _ref1 : _k > _ref1; 0 <= _ref1 ? _k++ : _k--) {
          newOp.push('out');
        }
      } else {
        newOp.push(c);
      }
    }
    return newOp;
  };

  fromMicros = json._fromMicros = function(micros) {
    return appendMicros([], micros);
  };

  appendMicros = function(op, micros) {
    var i, inRun, last, m;
    i = 0;
    while (i < micros.length) {
      m = micros[i];
      last = op.length ? op[op.length - 1] : null;
      if (m === 'in') {
        inRun = [];
        while (micros[i] === 'in' && (micros[i + 1].skip != null)) {
          inRun.push(micros[i + 1].skip);
          i += 2;
        }
        if (last && last["in"] && inRun.length) {
          last["in"] = last["in"].concat(inRun);
        } else {
          op.push({
            "in": inRun
          });
        }
        if (inRun.length) {
          continue;
        }
      } else if (m.skip != null) {
        if (last && last["in"] && last["in"].length === 0) {
          last["in"].push(m.skip);
        } else {
          op.push(m);
        }
      } else if (m === 'out') {
        if (last && (last.out != null)) {
          last.out++;
        } else {
          op.push({
            out: 1
          });
        }
      } else {
        op.push(m);
      }
      i++;
    }
    return op;
  };

  json.apply = function(snapshot, op) {
    var c, container, d, destinations, goIn, goOut, inventory, k, obj, parents, positions, skip, _i, _j, _k, _len, _len1, _ref, _ref1;
    json.checkValidOp(op);
    op = clone(op);
    container = {
      data: clone(snapshot)
    };
    parents = [container];
    positions = ['data'];
    destinations = {};
    inventory = {};
    goIn = function() {
      if (positions[0] == null) {
        throw new Error('Nowhere to go in');
      }
      parents.unshift(parents[0][positions[0]]);
      if (typeof parents[0] !== 'object') {
        throw new Error('invalid container');
      }
      return positions.unshift(null);
    };
    goOut = function() {
      parents.shift();
      return positions.shift();
    };
    skip = function(n) {
      if ((typeof n === 'number') !== (isArray(parents[0]))) {
        throw new Error('invalid skip');
      }
      if (typeof n === 'string') {
        if ((positions[0] != null) && n < positions[0]) {
          throw new Error("Can't skip backwards");
        }
        return positions[0] = n;
      } else {
        if (!(n > 0)) {
          throw new Error("Can't skip backwards");
        }
        return positions[0] += n;
      }
    };
    for (_i = 0, _len = op.length; _i < _len; _i++) {
      c = op[_i];
      if (c["in"]) {
        if (!isArray(c["in"])) {
          throw Error('not implemented');
        }
        _ref = c["in"];
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          k = _ref[_j];
          goIn();
          skip(k);
        }
      } else if (c.out != null) {
        for (_k = 1, _ref1 = c.out; 1 <= _ref1 ? _k <= _ref1 : _k >= _ref1; 1 <= _ref1 ? _k++ : _k--) {
          goOut();
        }
      } else if (c.skip != null) {
        skip(c.skip);
      } else if (c.drop != null) {
        obj = inventory[c.drop];
        console.log('obj', obj);
        console.log(positions);
        if (typeof positions[0] === 'number') {
          parents[0].splice(positions[0], 0, obj);
          skip(1);
        } else {
          parents[0][positions[0]] = obj;
        }
        if (obj === void 0) {
          destinations[c.drop] = [parents[0], positions[0]];
        } else {
          delete inventory[c.drop];
        }
      } else if (c.pick != null) {
        obj = parents[0][positions[0]];
        if (typeof positions[0] === 'number') {
          parents[0].splice(positions[0], 1);
        } else {
          delete parents[0][positions[0]];
        }
        d = destinations[c.pick];
        console.log('d:', d, 'obj', obj);
        if (d) {
          d[0][d[1]] = obj;
          delete destinations[c.pick];
        } else {
          if (c.pick in inventory) {
            throw new Error('Duplicate pick');
          }
          inventory[c.pick] = obj;
        }
        inventory;
      }
    }
    if (Object.keys(inventory).length || Object.keys(destinations).length) {
      console.log("inv", inventory);
      console.log("dest", destinations);
      throw new Error('mismatched pickups and drops');
    }
    return container.data;
  };

  makeIter = function(op) {
    var idx, offset, path, peek, take;
    path = [];
    idx = 0;
    offset = 0;
    take = function(maxSkip) {
      var c, part;
      if (idx === op.length) {
        return null;
      }
      c = op[idx];
      if (c.skip != null) {
        if (typeof c.skip === 'number') {
          if ((maxSkip == null) || c.skip - offset <= maxSkip) {
            part = offset ? {
              skip: c.skip - offset
            } : c;
            ++idx;
            offset = 0;
            return part;
          } else {
            offset += maxSkip;
            return {
              skip: maxSkip
            };
          }
        } else {
          if ((maxSkip == null) || (offset || c.skip) <= maxSkip) {
            ++idx;
            offset = 0;
            return c;
          } else {
            offset = maxSkip;
            return {
              skip: maxSkip
            };
          }
        }
      } else if (c === 'up' && (maxSkip != null)) {
        return {
          skip: maxSkip
        };
      } else {
        ++idx;
        return c;
      }
    };
    peek = function() {
      return op[idx];
    };
    return [take, peek];
  };

  json.transform = function(op, otherOp, side) {
    var base, c, depth, dest, destinations, inventory, newOp, other, path, peek, pos, pump, suspendedDepth, take, _i, _len, _ref, _ref1;
    console.log('x', op, otherOp, side);
    if (side !== 'left' && side !== 'right') {
      throw new Error("side (" + side + ") must be 'left' or 'right'");
    }
    checkOp(op);
    checkOp(otherOp);
    newOp = [];
    _ref = makeIter(toMicros(op)), take = _ref[0], peek = _ref[1];
    inventory = {};
    destinations = {};
    base = null;
    pump = function(n, depth) {
      var c;
      if (depth == null) {
        depth = 0;
      }
      while (true) {
        c = peek();
        if (c == null) {
          return;
        }
        if ((c.skip != null) && depth === 0) {
          append(newOp, take(n));
          if (c.skip >= n) {
            return;
          }
          if (typeof n === 'number') {
            n += c.skip;
          } else {
            n = c.skip;
          }
        } else {
          if (c === 'in') {
            depth++;
          } else if (c === 'out') {
            if (depth === 0) {
              return;
            }
            depth--;
          }
          append(newOp, take());
          if (depth === 0 && n === null) {
            return;
          }
        }
      }
    };
    suspendedDepth = 0;
    path = [];
    pos = null;
    _ref1 = toMicros(otherOp);
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      other = _ref1[_i];
      if (suspendedDepth) {
        if (other === 'in') {
          path.push(pos);
          pos = null;
          suspendedDepth++;
        } else if (other === 'out') {
          pos = path.pop();
          suspendedDepth--;
        } else if (other.skip != null) {
          if (typeof other.skip === 'number') {
            pos += other.skip;
          } else {
            pos = other.skip;
          }
        }
        continue;
      }
      if (other === 'in') {
        c = peek();
        if (c === 'in') {
          append(newOp, take());
        } else {
          depth = 1;
        }
      } else if (other.skip != null) {
        dest = other.skip;
        depth = 0;
        while (true) {
          append(newOp, c = take());
          if (((c.skip != null) && depth === 0 && c.skip >= dest) || (depth === 0 && c === 'out')) {
            break;
          } else {
            if (c === 'in') {
              depth++;
            } else if (c === 'out') {
              depth--;
            }
          }
        }
      }
    }
    return newOp;
  };

  json.pathMatches = function(p1, p2, ignoreLast) {
    var i, p, _i, _len;
    if (p1.length !== p2.length) {
      return false;
    }
    for (i = _i = 0, _len = p1.length; _i < _len; i = ++_i) {
      p = p1[i];
      if (p !== p2[i] && (!ignoreLast || i !== p1.length - 1)) {
        return false;
      }
    }
    return true;
  };

  json.append = function(dest, c) {
    throw new Error('not implemented');
  };

  json.compose = function(op1, op2) {
    var newOp;
    json.checkValidOp(op1);
    json.checkValidOp(op2);
    newOp = clone(op1);
    return newOp;
  };

  json.normalize = function(op) {
    var c, newOp, _i, _len;
    newOp = [];
    if (!isArray(op)) {
      op = [op];
    }
    for (_i = 0, _len = op.length; _i < _len; _i++) {
      c = op[_i];
      if (c.p == null) {
        c.p = [];
      }
      json.append(newOp, c);
    }
    return newOp;
  };

  clone = function(o) {
    return JSON.parse(JSON.stringify(o));
  };

  json.canOpAffectOp = function(otherPath, path) {
    var i, p, _i, _len;
    if (otherPath.length === 0) {
      return true;
    }
    if (path.length === 0) {
      return false;
    }
    path = path.slice(0, path.length - 1);
    otherPath = otherPath.slice(0, otherPath.length - 1);
    for (i = _i = 0, _len = otherPath.length; _i < _len; i = ++_i) {
      p = otherPath[i];
      if (i >= path.length) {
        return false;
      }
      if (p !== path[i]) {
        return false;
      }
    }
    return true;
  };

  if (typeof WEB !== "undefined" && WEB !== null) {
    exports.types || (exports.types = {});
    exports.types.json = json;
  } else {
    module.exports = json;
  }

}).call(this);
